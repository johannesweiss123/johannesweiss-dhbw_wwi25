package de.dhbw;import org.junit.jupiter.api.Test;import java.io.FileWriter;import java.io.IOException;import java.net.InetAddress;import java.text.SimpleDateFormat;import java.util.Base64;import java.util.Date;/** * Jede Testausführung schreibe Inhalte in eine Datei namens ID.log. * Spätestens wenn ihr euer Analyseergebnis habt, müsst ihr auch die Datei commiten. * In der Commit Nachricht muss für mich erkennbar sein, dass dies der Commit ist, in dem euer finales Analyseergebnis ist. */class DebuggingTest {    HappyLeapYearDetector underTest = new HappyLeapYearDetector();    @Test    void task1() {        String inputYear = parse("MjAyeA==");        underTest.isHappyLeapYear(inputYear);        // TODO: In welcher Zeile in deinem Code tritt die Exception auf? Was ist das Problem?        // Bei der Ausführung des Tests wird eine ID generiert. Notiere diese zusammen mit dem Ergebnis deiner Analyse hier im Code als Kommentar.        // Task1:        //ID: TWFjQm9vay1BaXItdm9uLUpvaGFubmVzLmxvY2FsX19fMjAyNS0xMS0xMyAxNzowNDo0NQ==        //ANALYSE: Beim Ausführen des Tests wird bei der Methode ein String eingegeben, aber ein Integer erwartet.        // Es kommt dann also bei der Main HappyLeapYearDetector in Zeile 35 zu der Fehlermeldung NumberformatException.forInputString.    }    @Test    void task2() {        String inputYear = parse("LTkyMTMxMjM=");        underTest.isHappyLeapYear(inputYear);        // TODO: Was ist hier komisch? Welche Regel würdest du hinzufügen? Programmiere die Regel (ggf. mit ChatGPT).        // Die neue Regel und der Implementierung dazu müssen in einem separaten Commit sein.        // DEIN ANALYSEERGEBNIS        // Neue ID TWFjQm9vay1BaXItdm9uLUpvaGFubmVzLmxvY2FsX19fMjAyNS0xMS0xMyAxNzo0NTo1NA==        // Der der String gibt eine negative Zahl aus. Die Methode aktzeptiert die Zahl aber ohne wirkliche Prüfung ob es eine gültige Jahreszahl ist.        // Es fehlt also eine Regel die ungültige Jahreszahlen überprüft. Neue Regel: if if (year < 0 || year > 9999) {        //    return false; damit werden keine negativen und keine zu hohen Jahreszahlen ausgegeben.    }    /**     * Diese Funktion ist für euch Studies völlig uninteressant. Hier gibt es nichts zu sehen ;-)     */    private static String parse(String src) {        String methodName = StackWalker.getInstance().walk(frames -> frames.skip(1).findFirst().get().getMethodName());        try (var writer = new FileWriter("ID.log", false)) {            String decoded = InetAddress.getLocalHost().getHostName() + "___" + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());            String encodedString = Base64.getEncoder().encodeToString(decoded.getBytes());            String str = "ID - " + methodName + ": " + encodedString;            writer.write(str);            System.out.println(new String(Base64.getDecoder().decode(encodedString)));        } catch (IOException e) {            System.out.println("Method: " + methodName);            System.out.println("Error writing file: " + e.getMessage());            System.out.println("Failed: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));        }        return new String(Base64.getDecoder().decode(src));    }}